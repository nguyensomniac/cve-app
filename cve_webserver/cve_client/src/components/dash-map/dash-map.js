import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import { Map, TileLayer, CircleMarker, Popup, GeoJSON } from 'react-leaflet';
import Control from 'react-leaflet-control';
import L from 'leaflet';
import chroma from 'chroma-js';

import styles from './dash-map.css';
import { ZIP_NAMES } from '../../const/const';

class DashMap extends Component {
  static propTypes = {
    bounds: PropTypes.arrayOf(PropTypes.array).isRequired,
    articles: PropTypes.array.isRequired,
    regions: PropTypes.shape({
      features: PropTypes.array
    }),
    currentZipCounts: PropTypes.object,
    filters: PropTypes.object,
    onClickRegion: PropTypes.func,
    onReleaseRegion: PropTypes.func,
    activeItem: PropTypes.object
  }

  constructor(props) {
    super(props);
    this.state = {
      jitter: {},
      tooltipContainers: {}
    }
  }

  setJitter(articles) {
    let jitters = this.state.jitter;
    for (let i = 0; i < articles.length; i++) {
      if (!jitters[articles[i].ID]) {
        const jitter = [(Math.random() - 0.5) * .0005, (Math.random() - 0.5) * .0005];
        jitters[articles[i].ID] = jitter;
      }
    }
    this.setState({
      jitter: jitters
    });
  }

  onClickRegion = (e) => {
    const regionData = e.target.feature;
    if (this.props.onClickRegion) {
      this.props.onClickRegion(regionData);
    }
  }

  onReleaseRegion = () => {
    if (this.props.onReleaseRegion) {
      this.props.onReleaseRegion();
    }
  }

  calcRegionStyle = (feature) => {
    const calcFillOpacity = () => {
      if (this.props.activeItem && this.props.activeItem.properties) {
        return (this.props.activeItem.properties.name == feature.properties.name) ? 0 : 0.6;
      } else {
        return 0.6
      }
    }
    const minArticles = Object.keys(this.props.currentZipCounts).reduce((currentMin, zip) => {
      return Math.min(currentMin, this.props.currentZipCounts[zip])
    }, Infinity);
    const maxArticles = Object.keys(this.props.currentZipCounts).reduce((currentMax, zip) => {
      return Math.max(currentMax, this.props.currentZipCounts[zip])
    }, -1 * Infinity)
    const currentCount = this.props.currentZipCounts[feature.properties.name];
    const scale = chroma.scale(['#B5CEFF', '#0A29FF']).domain([minArticles, maxArticles]).mode('lab');
    const fillColor = (currentCount) ? scale(this.props.currentZipCounts[feature.properties.name]).hex() : '#cccccc';
    return {
      color: fillColor,
      weight: 2,
      opacity: 0.6,
      fillOpacity: calcFillOpacity()
    }
  }

  getMapBounds = () => {
    if (!this.props.activeItem || !Object.keys(this.props.activeItem).length) {
      return this.props.bounds;
    } else {
      const flattenedPoints = [].concat(this.props.activeItem.geometry.coordinates);
      const bounds = L.latLngBounds(flattenedPoints);
      const northeast = bounds.getNorthEast();
      const southwest = bounds.getSouthWest();
      return [
        [northeast.lng, northeast.lat],
        [southwest.lng, southwest.lat]
      ]
    }
  }

  // bind tooltip and event listeners to each feature in GeoJSON data,
  // passed to GeoJSON react object.
  bindOnEachRegion = (feature, layer) => {
    // ReactDOM requires a containing node to render to. So let's create our own.
    const container = document.createElement('div');
    let oldContainers = this.state.tooltipContainers;
    oldContainers[feature.properties.name] = container;
    this.setState({
      tooltipContainers: oldContainers
    }, this.renderTooltipContent(feature.properties.name))

    layer.bindTooltip(container, {sticky: true});
    layer.on({
      'click': this.onClickRegion
    })
  }

  renderTooltipContent = (zip) => {
    const container = this.state.tooltipContainers[zip];
    if (!container) { return; }
    const neighborhoodName = ZIP_NAMES[zip];
    const zipCount = this.props.currentZipCounts[zip] || 0;
    ReactDOM.render(
      (
        <div>
          {zip}: {neighborhoodName}
          {zipCount}
        </div>
      ),
      container
    )
  }

  renderRegionsIfNeeded() {
    if (this.props.regions && Object.keys(this.props.regions).length) {
      return (
        <GeoJSON
          data={this.props.regions}
          style={this.calcRegionStyle}
          onEachFeature={this.bindOnEachRegion}
          filter={this.regionFilter}
        />
      )
    }
  }

  renderMarkersIfNeeded() {
    if (!this.props.articles) { return; }
    return (
      <div>
        {this.props.articles.map((article, i) => {
          if (!Number(article.Lat) || !Number(article.Lon)) { return null; }
          const jitteredLat = Number(article.Lat) + this.state.jitter[article.ID][0];
          const jitteredLon = Number(article.Lon) + this.state.jitter[article.ID][1];
          return (
            <div key={article.ID}>
              <CircleMarker radius={5} center={[jitteredLat, jitteredLon]} stroke={false} color={"#32DCF6"} opacity={0.75}>
                <Popup>
                  <span>
                    <a href={article.URL}>
                      {article.Title}
                    </a>
                  </span>
                </Popup>
              </CircleMarker>
            </div>
          )
        })}
      </div>
    )
  }

  renderBackButtonIfNeeded() {
    if (this.props.activeItem && this.props.activeItem.properties) {
      return (
        <Control>
          <div onClick={this.onReleaseRegion}>Go Back</div>
        </Control>
      )
    }
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.articles.length && nextProps.articles.length !== this.props.articles.length) {
      this.setJitter(nextProps.articles);
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.currentZipCounts !== this.props.currentZipCounts) {
      Object.keys(this.props.currentZipCounts).map((zip) => {
        this.renderTooltipContent(zip);
      })
    }
  }
  render() {
    return (
      <div className={styles.container}>
        <Map
          className={styles.map}
          bounds={this.getMapBounds()}
          scrollWheelZoom={false}
          useFlyTo={true}
        >
          <TileLayer url="https://api.mapbox.com/styles/v1/nguyensomniac/cj1q3lnh9002w2rpipklrlizw/tiles/512/{z}/{x}/{y}?access_token=pk.eyJ1Ijoibmd1eWVuc29tbmlhYyIsImEiOiJjaWZhNjY4OXQxeHgyczRtNzZ4OTVnbHFuIn0.auDKPGYvamGNI0tCmG_6bw"/>
          {this.renderMarkersIfNeeded()}
          {this.renderRegionsIfNeeded()}
          {this.renderBackButtonIfNeeded()}
        </Map>
      </div>
    )
  }
}

export default DashMap;
